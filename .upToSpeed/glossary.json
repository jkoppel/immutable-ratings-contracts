[
  {
    "terms": [
      "Liquidity Provider"
    ],
    "definition": "# Liquidity Provider\n\nIn decentralized finance (DeFi), a liquidity provider is a user who deposits pairs of assets (typically tokens) into a protocol's liquidity pool to enable trading. These participants are essential to decentralized exchanges (DEXs) as they create the markets that traders use. Liquidity providers earn rewards in the form of trading fees proportional to their share of the pool, and receive special LP (liquidity provider) tokens representing their position. While providing liquidity helps maintain price stability and market efficiency, providers face risks such as impermanent loss when asset prices in their provided pair diverge significantly.\n\nNote: In the Immutable Ratings codebase specifically, there are no liquidity providers in the traditional DeFi sense. The system instead focuses on rating URLs through token minting (TUP and TDN tokens) rather than facilitating token exchanges through liquidity pools."
  },
  {
    "terms": [
      "Volatility"
    ],
    "definition": "# Volatility\n\nIn the context of the Immutable Ratings platform, volatility refers to the rate and magnitude of change in rating balances for URL markets over time. As users submit positive (TUP) and negative (TDN) ratings for websites, rapid fluctuations in these token balances can indicate unstable or contested sentiment about a given URL.\n\nThe platform's design, with its minimum rating amount (1000 tokens) and per-token fee structure, creates a cost barrier that may help reduce rating volatility by discouraging frivolous or rapidly changing submissions. This is similar to how transaction fees in blockchain networks can dampen market volatility by adding friction to rapid trading.\n\nWhen analyzing a URL's rating data, periods of high volatility might suggest controversial content or coordinated rating campaigns, while stable rating balances could indicate more consistent public sentiment. Since the ratings are immutable on the blockchain, the historical volatility patterns for any URL market become permanent, verifiable records of how public opinion has evolved over time."
  },
  {
    "terms": [
      "Arbitrage"
    ],
    "definition": "# Arbitrage\n\nIn the context of Web3 and blockchain systems like Immutable Ratings, arbitrage refers to the practice of exploiting price or value differences between different markets to generate risk-free profits. While not directly implemented in the Immutable Ratings codebase, its token-based rating system creates potential conditions for arbitrage. \n\nThe platform uses two ERC20 tokens (TUP and TDN) to represent positive and negative ratings for URLs, with each URL having its own unique market address. Theoretically, arbitrage opportunities could emerge if:\n\n1. The cost of minting ratings (paid in ETH) differs from the market value of the resulting tokens\n2. Different exchanges list these rating tokens at varying prices\n3. Market inefficiencies create opportunities to profit from discrepancies between a URL's perceived rating value and its token balance\n\nIn broader blockchain contexts, arbitrage is fundamental to maintaining price equilibrium across decentralized exchanges and serves as a key mechanism for market efficiency, though it often requires sophisticated monitoring systems and rapid execution to capitalize on fleeting price differences."
  },
  {
    "terms": [
      "Slippage"
    ],
    "definition": "# Slippage\n\nIn the context of blockchain transactions, slippage refers to the difference between the expected price of a transaction and the actual price when the transaction is executed on-chain. While this concept is critical in decentralized exchanges where prices fluctuate constantly, the Immutable Ratings platform specifically avoids slippage by implementing fixed, deterministic pricing for rating submissions.\n\nThe platform uses a constant rate (0.00000007 ETH per token) for creating ratings, with functions like `previewPayment()` showing users the exact cost before submission. The `_processPayment()` function enforces this fixed price, reverting transactions with insufficient payment and refunding any excess. This design eliminates the uncertainty and potential loss that slippage typically introduces in other DeFi applications."
  },
  {
    "terms": [
      "Spread"
    ],
    "definition": "# Spread\n\nIn the context of cryptocurrency and decentralized finance, \"spread\" typically refers to the difference between buying and selling prices of an asset. Within the Immutable Ratings platform, however, spread relates to the distribution of collected fees to various stakeholders.\n\nThe codebase shows that fees collected from rating submissions are sent to specific receiver addresses that point to Splits contracts:\n\n```typescript\n// deployments.ts\nexport const deployConfig = {\n  // Base Sepolia\n  84532: {\n    receiver: \"0x30e7120ce8c0ABA197f1C4EccF2F4E1e1C75ab1d\", // https://app.splits.org/accounts/...\n  },\n  // Base Mainnet\n  8453: {\n    receiver: \"0xc1Ec5b421905290F477C741ADf97c062921AA18A\", // https://app.splits.org/accounts/...\n  },\n};\n```\n\nThese Splits contracts automatically distribute or \"spread\" the incoming funds among multiple recipients according to predefined proportions. This mechanism allows for transparent, trustless revenue sharing among project contributors, stakeholders, or other designated parties without requiring manual distribution."
  },
  {
    "terms": [
      "Order Book"
    ],
    "definition": "# Order Book\n\nIn the context of decentralized exchanges (DEXs), an Order Book is a trading mechanism that maintains a record of all buy and sell orders for assets at various price points. It represents a hybrid approach that combines traditional Central Limit Order Book (CLOB) functionality with Automated Market Maker (AMM) liquidity pools.\n\nOrder Books in DEXs allow traders to:\n- Place limit orders that execute only at specific prices\n- View pending orders organized by price levels\n- Access improved price discovery through visible supply and demand\n- Execute trades when buy and sell orders match at compatible prices\n\nUnlike the Immutable Ratings system shown in the provided code (which tracks ratings for URLs using token balances), a true Order Book system would facilitate trade matching and execution between parties. Order Books enhance capital efficiency by allowing liquidity providers to concentrate their assets at specific price points rather than across an entire curve.\n\nThe implementation typically involves smart contracts that manage order placement, cancellation, and execution, while maintaining the decentralized principles of blockchain technology."
  },
  {
    "terms": [
      "Market Depth"
    ],
    "definition": "# Market Depth\n\nIn the Immutable Ratings platform, \"Market Depth\" refers to the accumulated volume of rating tokens (TUP for positive ratings and TDN for negative ratings) held by a specific market address corresponding to a URL. Unlike traditional financial markets where depth indicates the ability to absorb large orders without price impact, here it represents the collective strength of community feedback for a particular web resource.\n\nEach URL has a deterministically generated market address that holds its ratings. When users submit ratings through `createUpRating()` or `createDownRating()` functions, the corresponding tokens are minted to this market address:\n\n```solidity\nfunction _createUpRating(address from, MarketRating calldata rating) internal {\n    address marketAddress = _getMarket(rating.url);\n    tokenUp.mint(from, marketAddress, rating.amount);\n    emit RatingUpCreated(from, marketAddress, rating.amount);\n}\n```\n\nA URL with greater market depth (more accumulated TUP and TDN tokens) indicates more extensive user participation in rating that content, potentially signaling more reliable consensus about its quality or trustworthiness. The depth is built through user ratings, each requiring a minimum amount (`MIN_RATING_AMOUNT`) and a corresponding fee payment."
  },
  {
    "terms": [
      "Limit Order"
    ],
    "definition": "# Limit Order\n\nIn this codebase, there's no implementation of a \"Limit Order\" concept. The Immutable Ratings system is designed for recording positive (TUP) and negative (TDN) ratings for URLs, not for trading assets at specified prices.\n\nThe core functionality involves:\n- Creating market addresses for URLs\n- Minting rating tokens to these addresses\n- Processing payments for ratings\n\nUnlike trading platforms where limit orders allow users to specify prices at which they want to buy or sell assets, this system focuses solely on immutable recording of ratings. The `MarketRating` struct contains only a URL and an amount, with no price specification or conditional execution logic that would be present in a limit order implementation."
  },
  {
    "terms": [
      "Stop-Loss Order"
    ],
    "definition": "# Stop-Loss Order\n\nA stop-loss order in decentralized exchanges (DEXs) is an automated risk management mechanism that executes a sell transaction when an asset's price falls to or below a predetermined threshold. Unlike traditional exchanges where orders are stored in a centralized order book, DEX stop-loss orders are implemented as smart contracts that autonomously monitor price feeds and execute trades directly on-chain when triggered.\n\nThese orders typically work by:\n1. A user depositing funds and setting a trigger price\n2. The contract monitoring price oracle feeds or on-chain liquidity pools\n3. Automatically executing a swap to sell the asset when the price threshold is reached\n\nIn DEXs, stop-loss orders face unique challenges including gas costs, price oracle reliability, and MEV (Miner Extractable Value) concerns. Advanced implementations may use mechanisms like flash loans for efficient execution or customizable hooks that allow integration with existing DEX protocols.\n\nWhile traditional stop-loss orders are custodial and rely on centralized matching engines, DEX stop-loss orders provide non-custodial protection, giving users full control of their assets until the trigger condition is met."
  },
  {
    "terms": [
      "Maker Fee"
    ],
    "definition": "# Maker Fee\n\nIn the Immutable Ratings platform, a \"maker fee\" refers to the payment users must provide in ETH when submitting ratings for URLs. Unlike traditional exchanges where maker fees incentivize liquidity providers, this fee is a straightforward cost for creating immutable rating records on the blockchain.\n\nThe fee is proportional to the rating amount and is calculated as 0.00000007 ETH per token unit:\n\n```javascript\n// Examples from tests\npreviewPayment(parseEther(\"1000\")) == parseEther(\"0.00007\")\npreviewPayment(parseEther(\"100000\")) == parseEther(\"0.007\")\n```\n\nWhen users create ratings through `createUpRating()` or `createDownRating()`, the contract:\n1. Validates the rating meets minimum requirements\n2. Processes the payment using `_processPayment()`\n3. Refunds any excess ETH sent\n4. Distributes the payment to a designated receiver address\n\nThe payment mechanism ensures the platform's sustainability while preventing spam or frivolous ratings by imposing a small but meaningful cost on each rating action."
  },
  {
    "terms": [
      "Taker Fee"
    ],
    "definition": "# Taker Fee\n\nIn the Immutable Ratings platform, a taker fee refers to the fixed payment required from users when they submit ratings for URLs. The system charges 0.00000007 ETH per token (with a minimum of 1000 tokens per rating). When users create ratings through `createUpRating()` or `createDownRating()`, the contract validates that sufficient ETH has been sent with the transaction via the `_processPayment()` function, refunds any excess, and forwards the fee to a designated receiver address. Unlike traditional exchange taker fees that vary based on liquidity removal, this fee uses a simple linear calculation where larger rating amounts require proportionally larger payments, as shown in the test file:\n\n```javascript\n// From test/immutable-ratings.test.ts\nexpect(await immutableRatings.previewPayment(parseEther(\"1000\"))).to.equal(parseEther(\"0.00007\"));\nexpect(await immutableRatings.previewPayment(parseEther(\"100000\"))).to.equal(parseEther(\"0.007\"));\n```"
  },
  {
    "terms": [
      "Margin Trading"
    ],
    "definition": "# Margin Trading\n\nMargin Trading is not a feature implemented in the Immutable Ratings platform. Based on the provided codebase, this platform is solely focused on creating a decentralized rating system where users submit positive (TUP) and negative (TDN) ratings for URLs. \n\nThe system uses deterministic \"market\" addresses to track ratings for specific URLs, but these \"markets\" are simply identifiers for content being rated, not trading venues. Users pay fees to submit ratings, but there's no mechanism for borrowing funds, leveraging positions, or providing collateral as would be found in margin trading systems.\n\nThe codebase shows only rating-related functionality:\n- Creating markets for URLs\n- Submitting up/down ratings\n- Minting corresponding tokens\n- Processing rating payments\n\nNo margin trading capabilities or related financial trading mechanisms are present in this system."
  },
  {
    "terms": [
      "Leverage"
    ],
    "definition": "# Leverage\n\nIn the context of smart contract development, **leverage** refers to the architectural pattern where one contract is granted specific permissions to utilize the capabilities of other contracts in a controlled manner. This creates a modular system where specialized contracts can be combined to build more complex functionality.\n\nIn the Immutable Ratings platform, leverage is demonstrated by how the core ImmutableRatings contract is granted minting privileges for both token contracts (TUP and TDN) through role-based access control:\n\n```solidity\n// From test/immutable-ratings.test.ts\nawait tup.grantRole(await tup.MINTER_ROLE(), immutableRatings.target);\nawait tdn.grantRole(await tdn.MINTER_ROLE(), immutableRatings.target);\n```\n\nThis pattern allows the controller contract to \"leverage\" the token contracts' minting functionality while maintaining separation of concerns and enabling the token contracts to remain focused on implementing the ERC20 standard. When users submit ratings, the controller leverages its minting permissions to create tokens in the appropriate market:\n\n```solidity\n// From contracts/ImmutableRatings.sol\nfunction _createUpRating(address from, MarketRating calldata rating) internal {\n    address marketAddress = _getMarket(rating.url);\n    tokenUp.mint(from, marketAddress, rating.amount);\n    emit RatingUpCreated(from, marketAddress, rating.amount);\n}\n```\n\nLeverage in this design enables composability and security by allowing contracts to access each other's functionality through well-defined interfaces and permission systems, rather than duplicating code or creating overly complex monolithic contracts."
  },
  {
    "terms": [
      "Hedging"
    ],
    "definition": "# Hedging\n\nIn the context of the Immutable Ratings platform, \"hedging\" is not a relevant or implemented concept. The system focuses on creating immutable records of positive (TUP) and negative (TDN) ratings for URLs, with no mechanisms for offsetting financial risks.\n\nThe codebase shows a straightforward rating system where tokens are minted to represent ratings:\n\n```solidity\n// From contracts/ImmutableRatings.sol\nfunction _createUpRating(address from, MarketRating calldata rating) internal {\n    address marketAddress = _getMarket(rating.url);\n    tokenUp.mint(from, marketAddress, rating.amount);\n    emit RatingUpCreated(from, marketAddress, rating.amount);\n}\n```\n\nUnlike decentralized exchanges where hedging strategies protect liquidity providers against impermanent loss or price volatility, the Immutable Ratings contracts don't involve asset pairs, liquidity pools, or price exposure that would require risk mitigation through hedging."
  },
  {
    "terms": [
      "Swap"
    ],
    "definition": "# Swap\n\nIn the context of blockchain systems, a **swap** refers to an operation where one token is exchanged for another through a smart contract without requiring intermediaries. \n\nWithin the Immutable Ratings system, though not explicitly implemented in the shared code, swaps would represent a mechanism by which users might exchange other tokens for the platform's rating tokens (TUP and TDN). The platform's architecture uses these tokens to represent positive and negative ratings for URLs.\n\nA typical swap implementation:\n- Takes input tokens from a sender\n- Calculates exchange rates based on established formulas or liquidity pools\n- Transfers the corresponding amount of output tokens to the recipient\n- Updates any relevant state variables\n- Emits events documenting the transaction details\n\nSwaps are fundamental to decentralized exchanges and token ecosystems, enabling value transfer between different token systems in a trustless environment."
  },
  {
    "terms": [
      "Futures"
    ],
    "definition": "# Futures\n\nIn the context of the Immutable Ratings platform, \"Futures\" is not a directly implemented feature. The platform is instead focused on creating an immutable, blockchain-based rating system for web URLs using two ERC20 tokens (TUP for positive ratings and TDN for negative ratings).\n\nWhile traditional futures contracts in finance represent agreements to buy or sell assets at predetermined prices at specified future times, the Immutable Ratings system does not implement such financial instruments. Instead, it uses a market-based approach where each URL has its own deterministic \"market address\" that accumulates token balances representing cumulative ratings.\n\nThe system's immutability refers to the permanent nature of the ratings once recorded on the blockchain, rather than to futures contracts. Any future updates to the platform would be deployed as separate contracts, as the existing ones are designed to be non-upgradeable."
  },
  {
    "terms": [
      "Options"
    ],
    "definition": "# Options\n\nIn the context of the Immutable Ratings platform, \"Options\" refers to configurable administrative settings and controls that allow the contract owner to modify system behavior and manage ownership. These options include:\n\n1. **Ownership Management**: The ability to transfer ownership of the contract to another address through a two-step process (transferOwnership and acceptOwnership).\n\n2. **Receiver Settings**: Configuration of the address that receives payment fees from rating submissions via the `setReceiver` function.\n\n3. **Pause Controls**: The ability to temporarily halt system functionality through the `setIsPaused` function, which can toggle the contract between active and paused states.\n\n4. **Payment Processing Options**: Internal mechanisms that handle fee collection, excess payment refunds, and payment distribution.\n\nThese administrative options provide the contract owner with flexibility to manage the platform while maintaining its security and reliability. The implementation uses OpenZeppelin's standard ownership and access control patterns to ensure these options can only be accessed by authorized addresses."
  },
  {
    "terms": [
      "Derivatives"
    ],
    "definition": "# Derivatives\n\nIn the context of blockchain applications like Immutable Ratings, derivatives would refer to financial instruments that derive their value from an underlying asset or data point within the system. While not explicitly implemented in the provided codebase, the Immutable Ratings platform creates a foundation that could support derivative products.\n\nThe system's architecture includes:\n- Market addresses for URLs that accumulate rating tokens\n- ERC20 tokens (TUP and TDN) representing positive and negative ratings\n\nPotential derivatives in this ecosystem could include:\n\n1. **Options contracts** giving rights to purchase TUP/TDN tokens at preset prices\n2. **Futures contracts** for speculating on future website ratings\n3. **Synthetic assets** tracking rating ratios across market segments\n4. **Swap contracts** exchanging value based on rating performance\n\nThese would be implemented as separate smart contracts interacting with the core Immutable Ratings system, using the ratings data as a price feed or oracle for more complex financial instruments."
  },
  {
    "terms": [
      "Stablecoin"
    ],
    "definition": "# Stablecoin\n\nA cryptocurrency designed to maintain a stable value by pegging to an external asset, typically a fiat currency like the US dollar. Unlike volatile cryptocurrencies such as Bitcoin or Ethereum, stablecoins aim to provide price stability through various mechanisms:\n\n1. **Fiat-collateralized**: Backed 1:1 by reserves of fiat currency (e.g., USDC, USDT)\n2. **Crypto-collateralized**: Backed by other cryptocurrencies, often over-collateralized (e.g., DAI)\n3. **Algorithmic**: Use smart contracts to programmatically manage supply and maintain price stability\n\nIn DeFi ecosystems, stablecoins serve critical functions:\n- Providing a reliable medium of exchange\n- Serving as a stable store of value during market volatility\n- Creating trading pairs in decentralized exchanges\n- Facilitating lending and borrowing in lending protocols\n- Enabling yield farming and liquidity provision\n\nStablecoins implement standard token interfaces (typically ERC-20 on Ethereum) allowing them to interact seamlessly with smart contracts across the blockchain ecosystem."
  },
  {
    "terms": [
      "Collateral"
    ],
    "definition": "# Collateral\n\nCollateral is not a specific component of the Immutable Ratings system described in the provided code. The Immutable Ratings platform is a decentralized rating system where users pay fees in ETH to submit positive (TUP) or negative (TDN) ratings for URLs, but it doesn't implement any collateral mechanism. \n\nIn typical DeFi contexts, collateral refers to assets that users deposit to secure positions or transactions, serving as a guarantee against potential losses. These assets can trigger liquidations if their value falls below predetermined thresholds. While this is a common pattern in lending protocols and decentralized exchanges, the Immutable Ratings system operates on a simpler fee-based model without requiring users to lock up assets as security."
  },
  {
    "terms": [
      "Yield Farming"
    ],
    "definition": "# Yield Farming\n\nYield farming is a DeFi (Decentralized Finance) investment strategy where users provide liquidity to protocols and earn rewards in return. Users deposit their crypto assets into liquidity pools or staking contracts to generate returns, which typically consist of trading fees, interest, or additional token rewards.\n\nBased on the provided Immutable Ratings codebase, yield farming is not implemented in this system. The platform focuses on creating an immutable rating system for web content using TUP (Thumbs Up) and TDN (Thumbs Down) tokens, with functionality for creating market addresses, submitting ratings, and collecting fees. The contracts (ImmutableRatings.sol, TUP.sol, and TDN.sol) do not contain components necessary for yield farming such as liquidity pools, staking mechanisms, reward distribution systems, or APY calculations."
  },
  {
    "terms": [
      "Staking"
    ],
    "definition": "# Staking\n\nStaking is a mechanism in decentralized systems where users lock up tokens in a smart contract as a form of participation, security, or incentivization. In traditional proof-of-stake blockchains, staking involves validators locking up native tokens to participate in consensus and earn rewards. In DeFi applications, staking often refers to depositing tokens (such as liquidity provider tokens) into dedicated contracts to earn additional rewards while providing value to the protocol.\n\nUnlike the Immutable Ratings system (which uses token minting to represent URL ratings), typical staking systems incorporate time-locked deposits, proportional reward distribution based on stake amount, and sometimes slashing mechanisms to penalize malicious behavior. Staking creates aligned incentives between token holders and protocol success, as stakers are motivated to act in ways that increase the value and utility of the protocol."
  },
  {
    "terms": [
      "APR (Annual Percentage Rate)",
      "APR",
      "Annual Percentage Rate"
    ],
    "definition": "# APR (Annual Percentage Rate)\n\nIn the Immutable Ratings system, APR (Annual Percentage Rate) is not explicitly implemented within the smart contracts. However, in a DeFi context, APR would represent the annualized rate of return that participants might expect from engaging with the platform's economy.\n\nWhile not coded directly into this system, APR could become relevant if:\n\n1. The collected rating fees (sent to the receiver address configured in `deployments.ts`) were distributed to stakeholders through the Splits contracts\n2. The platform's TUP and TDN tokens acquired market value and generated returns for holders\n3. Future versions implemented staking mechanisms with rewards\n\nThe payment system shown in `_processPayment()` and the fee calculations demonstrated in the test files could form the basis of APR calculations if the platform ever implemented a rewards mechanism based on these fees.\n\nAPR serves as an important metric for users to evaluate potential investment returns, typically calculated off-chain based on actual performance data rather than being hardcoded within smart contracts."
  },
  {
    "terms": [
      "APY (Annual Percentage Yield)",
      "APY",
      "Annual Percentage Yield"
    ],
    "definition": "# APY (Annual Percentage Yield)\n\nAnnual Percentage Yield (APY) represents the effective annual rate of return on an investment when accounting for compound interest. In blockchain applications like the Immutable Ratings platform, APY would indicate the annualized return participants might receive when engaging with the protocol's economic mechanisms.\n\nUnlike simple interest (APR), APY factors in compounding effects, making it a more accurate representation of actual returns over time. The mathematical formula for APY is:\n\n```\nAPY = (1 + r/n)^n - 1\n```\n\nWhere:\n- r = periodic rate\n- n = number of compounding periods per year\n\nWhile not explicitly implemented in the current Immutable Ratings contracts, APY could be relevant for future token economics such as staking TUP/TDN tokens, providing liquidity in trading pairs, or incentivizing consistent rating participation. APY-based reward systems would likely require tracking time-based participation and implementing periodic reward calculations through smart contract functions."
  },
  {
    "terms": [
      "Gas Fee"
    ],
    "definition": "# Gas Fee\n\nIn blockchain systems like Ethereum, a gas fee is the cost that users pay to execute transactions or run smart contract operations. Think of it as a processing fee for using the blockchain's computational resources.\n\nThe Immutable Ratings platform requires gas fees for two main purposes:\n\n1. **Network Transaction Fee**: The standard fee paid to blockchain validators for processing your transaction.\n\n2. **Protocol-Specific Payment**: A fixed fee for rating submissions calculated as 0.00000007 ETH per token, as shown in the `_processPayment` function:\n\n```solidity\n// From contracts/ImmutableRatings.sol\nfunction _processPayment(uint256 amount) internal {\n    uint256 price = _getRatingPrice(amount);\n    if (msg.value < price) revert InsufficientPayment();\n    _refundExcessPayment(msg.value - price);\n    _distributePayment(price);\n}\n```\n\nUsers can preview the cost for different rating amounts using the `previewPayment` function before submitting a transaction, helping them estimate their total costs:\n\n```javascript\n// Example payment calculations from tests\nexpect(await immutableRatings.previewPayment(parseEther(\"1000\"))).to.equal(parseEther(\"0.00007\"));\nexpect(await immutableRatings.previewPayment(parseEther(\"100000\"))).to.equal(parseEther(\"0.007\"));\n```\n\nGas fees vary based on network congestion and the complexity of operations, making them an important consideration for users of decentralized applications."
  },
  {
    "terms": [
      "Smart Contract"
    ],
    "definition": "# Smart Contract\n\nA smart contract is a self-executing program stored on a blockchain that automatically enforces predefined rules and conditions without requiring intermediaries. Unlike traditional contracts, smart contracts run as code on a decentralized network, executing automatically when specific conditions are met.\n\nIn the Immutable Ratings platform, smart contracts form the foundation of the decentralized rating system:\n\n- **ImmutableRatings.sol** controls the creation of market addresses for URLs and manages rating submissions\n- **TUP.sol** and **TDN.sol** are ERC20 token contracts representing positive and negative ratings\n\nThese contracts demonstrate key characteristics of smart contracts:\n\n1. **Autonomous execution**: The contracts automatically mint rating tokens when users submit ratings, without manual intervention\n2. **Immutability**: Once deployed, the contracts cannot be modified, ensuring rating data remains permanent\n3. **Transparency**: All contract operations are visible on the blockchain\n4. **Trustless operation**: Users can interact with the system without trusting a central authority\n\nSmart contracts enable decentralized applications by codifying business logic and rules that execute predictably on the blockchain, removing the need for trusted third parties while providing security, transparency, and efficiency."
  },
  {
    "terms": [
      "DeFi"
    ],
    "definition": "# DeFi\n\nDecentralized Finance (DeFi) refers to a blockchain-based financial ecosystem that operates without centralized intermediaries like banks or traditional financial institutions. It uses smart contracts to create transparent, permissionless financial services accessible to anyone with an internet connection and a compatible wallet.\n\nDeFi applications typically feature:\n\n1. **Non-custodial protocols** where users maintain control of their assets\n2. **Smart contract automation** that executes financial operations without human intervention\n3. **Tokenization** of assets and financial services using standards like ERC20\n4. **Composability** where different protocols can interact seamlessly (often called \"money legos\")\n5. **Transparent operations** with all transactions recorded on public blockchains\n\nIn a codebase like Immutable Ratings, we see DeFi principles applied through ERC20 token implementation, permission-based minting, deterministic market addresses, and transparent operations recorded on-chain. While not all blockchain applications are DeFi, those focused on creating financial services (lending, trading, asset management, ratings systems with economic incentives) that operate without trusted intermediaries fall under the DeFi umbrella."
  },
  {
    "terms": [
      "CeFi"
    ],
    "definition": "# CeFi\n\nCentralized Finance (CeFi) refers to cryptocurrency financial services managed by centralized entities that act as intermediaries between users and blockchain networks. Unlike DeFi (Decentralized Finance), CeFi platforms maintain custody of user funds, implement KYC/AML procedures, and provide more traditional user experiences. CeFi includes centralized exchanges (like Coinbase or Binance), lending platforms, and custodial wallets that offer crypto-based financial services with the familiar interface of traditional banking. While CeFi sacrifices some blockchain principles like trustlessness and decentralization, it typically offers better user experience, customer support, and regulatory compliance. For blockchain developers, understanding CeFi is important for building systems that can interact with these mainstream on/off ramps that connect traditional finance to the cryptocurrency ecosystem."
  },
  {
    "terms": [
      "DAO"
    ],
    "definition": "# DAO\n\nA Decentralized Autonomous Organization (DAO) is a blockchain-based governance structure where decision-making authority is distributed among stakeholders (typically token holders) rather than centralized in traditional hierarchical management. DAOs operate through smart contracts that automatically execute decisions based on community votes, enabling transparent, trustless coordination without central authorities.\n\nUnlike the Immutable Ratings platform which uses a traditional ownership model (via OpenZeppelin's Ownable pattern), DAOs implement voting mechanisms where token holders can propose, debate, and vote on changes to the protocol, treasury allocations, or other governance decisions. This creates an internet-native organization that is collectively owned and managed by its members, with rules and transaction records transparently stored on the blockchain.\n\nDAOs represent a fundamental shift from centralized to community-driven governance, allowing groups to coordinate resources and make decisions without requiring participants to trust each other or any central authority."
  },
  {
    "terms": [
      "Liquidity Mining"
    ],
    "definition": "# Liquidity Mining\n\nLiquidity mining is a DeFi incentive mechanism where users provide liquidity to trading pools and receive token rewards in return. In practice, users deposit pairs of tokens into liquidity pools (often on decentralized exchanges), receiving LP (Liquidity Provider) tokens that represent their share of the pool. By staking these LP tokens in designated smart contracts, users earn additional reward tokens over time, typically distributed proportionally to their contribution. This creates a mutually beneficial relationship: protocols acquire the liquidity needed for efficient trading, while liquidity providers earn rewards beyond standard trading fees. However, liquidity providers should be aware of risks like impermanent loss, where price divergence between paired assets can result in opportunity costs compared to simply holding those assets."
  },
  {
    "terms": [
      "Protocol Fee"
    ],
    "definition": "# Protocol Fee\n\nA protocol fee in decentralized systems is a transaction fee collected by the protocol itself rather than external parties. In the context of Immutable Ratings, this fee is implemented as a payment required for users to submit ratings to the platform.\n\nKey characteristics of the protocol fee in Immutable Ratings:\n\n- Users must pay in ETH to submit ratings for URLs\n- The fee scales proportionally with the rating amount (0.00000007 ETH per token)\n- Payments can be previewed using the `previewPayment` function\n- The contract validates that sufficient payment is included with each transaction\n- Excess payments are automatically refunded to users\n- Collected fees are distributed to a designated receiver address\n- The fee mechanism can be paused by the contract owner\n\nAs shown in the code:\n\n```solidity\n// From ImmutableRatings.sol\nfunction _processPayment(uint256 amount) internal {\n    uint256 price = _getRatingPrice(amount);\n    if (msg.value < price) revert InsufficientPayment();\n    _refundExcessPayment(msg.value - price);\n    _distributePayment(price);\n}\n```\n\nProtocol fees serve both as an economic incentive mechanism to prevent spam and as a means to fund continued development and maintenance of the platform."
  },
  {
    "terms": [
      "ERC20"
    ],
    "definition": "# ERC20\n\nERC20 is a technical standard for fungible tokens on the Ethereum blockchain that defines a common interface of functions and events that tokens must implement. In the Immutable Ratings platform, ERC20 serves as the foundation for the TUP (Thumbs Up) and TDN (Thumbs Down) tokens that represent positive and negative ratings.\n\nThe standard defines core functionality including:\n- `transfer`: Move tokens from sender to recipient\n- `approve`: Allow a third party to spend tokens\n- `transferFrom`: Transfer approved tokens on behalf of another address\n- `balanceOf`: Check token balance of an address\n- `allowance`: Check how many tokens a spender is approved to use\n\nIn the codebase, both token contracts inherit from OpenZeppelin's ERC20 implementation:\n\n```solidity\n// From TUP.sol and TDN.sol\nconstructor() ERC20(\"Thumbs Up\", \"TUP\") {\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n}\n```\n\nThe system utilizes access control to ensure only authorized addresses can mint tokens:\n\n```solidity\nfunction mint(address minter, address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n    upvotes[minter] += amount;\n}\n```\n\nBy leveraging the ERC20 standard, Immutable Ratings gains interoperability with wallets, exchanges, and other DeFi applications, while maintaining a secure and standardized approach to token management."
  },
  {
    "terms": [
      "ERC1155"
    ],
    "definition": "# ERC1155\n\nERC1155 is a token standard on the Ethereum blockchain that enables the creation and management of multiple token types within a single smart contract. Unlike ERC20 (fungible tokens) or ERC721 (non-fungible tokens) which require separate contracts for each token type, ERC1155 allows both fungible and non-fungible tokens to coexist in the same contract.\n\nKey features include:\n- **Batch operations**: Multiple tokens can be transferred in a single transaction, significantly reducing gas costs\n- **Semi-fungibility**: Tokens can have properties of both fungible and non-fungible tokens\n- **Gas efficiency**: Shares common functionality across token types instead of replicating code\n- **Metadata handling**: Provides standardized metadata handling for all tokens\n\nWhile not implemented in the Immutable Ratings codebase (which uses separate ERC20 tokens for TUP and TDN ratings), ERC1155 would potentially allow such a system to combine multiple rating token types into a single contract with improved efficiency."
  },
  {
    "terms": [
      "ERC6909"
    ],
    "definition": "# ERC6909\n\nERC6909 is a modern, gas-efficient Ethereum token standard designed for managing multiple fungible tokens within a single smart contract. Unlike ERC20, which requires deploying separate contracts for each token type, ERC6909 allows different tokens to be issued from the same contract using unique token IDs.\n\nThe standard provides a minimal interface focused on core token operations:\n- Tracking balances for multiple token IDs per address\n- Transferring tokens between addresses\n- Managing operator approvals for third-party transfers\n- Supporting minting and burning operations\n\nKey benefits include:\n- Significantly reduced gas costs for token operations\n- Simplified token management through a unified interface\n- Native batch operations for efficient multi-token transfers\n- Streamlined approval mechanisms\n\nERC6909 is particularly valuable for applications requiring frequent token operations or managing multiple related token types, such as gaming assets, liquidity management systems, or rating platforms that track different types of tokens like the \"Thumbs Up\" and \"Thumbs Down\" tokens seen in the Immutable Ratings platform."
  },
  {
    "terms": [
      "X96"
    ],
    "definition": "# X96\n\nX96 refers to a binary fixed-point number format commonly used in decentralized finance (DeFi) smart contracts, particularly in automated market makers like Uniswap V3. The \"96\" indicates that numbers are scaled by multiplying them by 2^96 before storing them as integers. This technique enables high-precision arithmetic operations in blockchain environments where native floating-point operations aren't available.\n\nThe format is particularly valuable when representing token price ratios, square roots of prices, or other decimal values requiring significant precision. By using this fixed-point representation, contracts can maintain computational accuracy while performing efficient mathematical operations using only integer arithmetic, which is crucial for gas optimization and precision in financial calculations.\n\nWhen you see a variable named with \"X96\" suffix (like `sqrtPriceX96`), it means the value stored is the actual number multiplied by 2^96, requiring appropriate scaling when converting back to a conventional decimal representation."
  },
  {
    "terms": [
      "Concentrated Liquidity"
    ],
    "definition": "# Concentrated Liquidity\n\nConcentrated liquidity is a capital efficiency innovation in decentralized exchange (DEX) protocols that allows liquidity providers to allocate their assets within specific price ranges rather than across the entire price spectrum. \n\nIn traditional automated market makers (AMMs) like Uniswap V2, liquidity is distributed uniformly across all possible price points from zero to infinity, which means most capital is rarely used. Concentrated liquidity solves this inefficiency by enabling providers to focus their capital where it's most likely to be utilized—typically around the current market price.\n\nThis mechanism works by having liquidity providers create positions with upper and lower price bounds. When the market price trades within this range, the position is active and earns trading fees. If the price moves outside the range, the position becomes inactive until prices return to the specified range. This targeted approach can significantly increase capital efficiency, potentially generating higher returns for liquidity providers while offering traders better pricing with reduced slippage.\n\nPioneered by Uniswap V3, concentrated liquidity represents a fundamental redesign of AMM mathematics, shifting from the simple constant product formula (x*y=k) to a more complex system that tracks liquidity positions individually across discrete price intervals or \"ticks.\""
  },
  {
    "terms": [
      "Constant Product Formula"
    ],
    "definition": "# Constant Product Formula\n\nThe Constant Product Formula (x * y = k) is the mathematical foundation of many Automated Market Makers (AMMs) in decentralized finance. In this equation, x and y represent the reserves of two tokens in a liquidity pool, while k is a constant value that must be maintained during all transactions. \n\nWhen users trade tokens in an AMM, they add one token to the pool and withdraw another. The formula automatically calculates how many tokens they receive based on the requirement that the product of both token reserves must remain unchanged. This creates a price curve where larger trades face progressively higher slippage, providing an elegant solution for permissionless trading without traditional order books.\n\nFor developers implementing AMMs, this formula determines:\n- How token swap amounts are calculated\n- How liquidity is added and removed from pools\n- How prices adjust in response to market activity\n\nThe elegant simplicity of the Constant Product Formula enables self-balancing liquidity pools that can operate without intermediaries, creating the foundation for decentralized exchanges like Uniswap."
  },
  {
    "terms": [
      "Invariant"
    ],
    "definition": "# Invariant\n\nAn invariant is a condition or property that must remain true throughout the execution of a program, regardless of the operations performed or the state of the system. In software engineering, invariants serve as critical guardrails that maintain system integrity and prevent unintended behaviors.\n\nIn the Immutable Ratings smart contract system, several key invariants are explicitly defined:\n\n```\n// From README.md\n1. Each unique URL can only have one market address.\n2. Market addresses are deterministic and cannot be changed.\n3. Only the ImmutableRatings contract can mint TUP and TDN tokens.\n4. Users must pay a fee to submit ratings.\n5. Rating amounts must be multiples of 1 ether and meet the minimum requirement.\n```\n\nInvariants are enforced through validation checks in the code:\n\n```solidity\n// From contracts/ImmutableRatings.sol\nfunction _validateRating(MarketRating calldata rating) internal pure {\n    if (rating.amount % 1 ether != 0 || rating.amount < MIN_RATING_AMOUNT) {\n        revert InvalidRatingAmount();\n    }\n}\n```\n\nAnd verified through comprehensive testing:\n\n```typescript\n// From test/immutable-ratings.test.ts\nit(\"should deploy ImmutableRatings\", async () => {\n  // ...\n  // Check has minter roles - verifying invariant #3\n  expect(await tdn.hasRole(await tdn.MINTER_ROLE(), immutableRatings.target)).to.be.true;\n  expect(await tup.hasRole(await tup.MINTER_ROLE(), immutableRatings.target)).to.be.true;\n});\n```\n\nProperly designed invariants are foundational to building robust and secure software systems, especially in smart contracts where code immutability makes post-deployment fixes costly or impossible."
  },
  {
    "terms": [
      "Mid Price"
    ],
    "definition": "# Mid Price\n\nIn decentralized exchanges (DEXs), the mid price represents the theoretical fair value of one token in terms of another within a liquidity pool. It's calculated as a function of the token reserves in the pool, commonly using a geometric mean formula.\n\nThe mid price indicates what the exchange rate would be for an infinitesimally small trade that doesn't impact the market - essentially the \"spot price\" at a given moment. It serves as a reference point rather than an actual execution price, as real trades incur slippage based on their size and the pool's liquidity depth.\n\nFor example, in a constant product AMM like Uniswap V2, if a pool contains reserves of tokens A and B, the mid price of A in terms of B would be the ratio of reserve B to reserve A. This differs from the actual execution price a trader receives, which follows the constant product formula x*y=k and changes as the trade impacts the reserves.\n\nThe mid price is commonly used for price oracles, strategy calculations, and as a benchmark to measure trading efficiency and slippage in DeFi applications."
  },
  {
    "terms": [
      "AMM Protocol",
      "Automated Market Maker",
      "AMM"
    ],
    "definition": "# AMM Protocol\n\nAn Automated Market Maker (AMM) protocol is a decentralized exchange mechanism that replaces traditional order books with liquidity pools managed by smart contracts. In an AMM, traders interact with a deterministic algorithm rather than other traders, enabling permissionless, 24/7 trading of digital assets.\n\nCore components of AMM protocols include:\n\n1. **Liquidity Pools**: Reserves of paired assets (like ETH/USDC) that traders can swap between\n2. **Pricing Algorithm**: Mathematical formula (commonly constant product formula `x*y=k`) that determines exchange rates based on pool ratios\n3. **Liquidity Providers**: Users who deposit assets into pools and earn trading fees in return\n4. **Slippage Mechanism**: Price impact that increases with trade size relative to pool depth\n\nPopular AMM implementations include Uniswap (constant product), Curve (stable assets), and Balancer (weighted pools). AMMs solved the liquidity problem for decentralized exchanges by enabling continuous market availability without requiring matched buy and sell orders.\n\nThe innovation of AMMs lies in their ability to provide reliable on-chain liquidity through mathematical certainty rather than relying on traditional market making approaches."
  },
  {
    "terms": [
      "address(0)"
    ],
    "definition": "# address(0)\n\nIn Ethereum and EVM-compatible blockchains, `address(0)` refers to the zero address: `0x0000000000000000000000000000000000000000`. This special address serves multiple critical functions in smart contracts:\n\n1. **Sentinel Value**: Commonly used to check whether an address has been initialized, especially in mappings where unassigned keys return `address(0)` by default.\n\n2. **Input Validation**: Used to validate that function parameters or constructor arguments contain valid addresses:\n   ```solidity\n   if (_tokenUp == address(0) || _tokenDown == address(0)) revert ZeroAddress();\n   ```\n\n3. **Existence Checking**: Determines if a record exists in mappings, as seen in the Immutable Ratings contract:\n   ```solidity\n   marketAddress = urlToMarket[url];\n   if (marketAddress == address(0)) {\n       marketAddress = _createMarket(url);\n   }\n   ```\n\n4. **Security Protection**: Prevents accidental token burns or permanent loss by blocking transfers to the zero address:\n   ```solidity\n   function recoverERC20(address tokenAddress, address recipient) external onlyOwner {\n       if (tokenAddress == address(0) || recipient == address(0)) revert ZeroAddress();\n       // ...\n   }\n   ```\n\n5. **Burn Address**: Sometimes intentionally used as a destination for tokens that should be permanently removed from circulation.\n\nThe zero address is particularly important for security, as sending assets to this address typically means they cannot be recovered. Well-designed contracts include explicit checks against `address(0)` to prevent such accidental losses."
  },
  {
    "terms": [
      "EIP-1153"
    ],
    "definition": "# EIP-1153\n\nEIP-1153 (Ethereum Improvement Proposal 1153) introduces Transient Storage Opcodes to the Ethereum Virtual Machine. This feature provides temporary storage that exists only for the duration of a transaction and is automatically cleared afterward. It adds two new opcodes: TLOAD (0x5c) for loading data from transient storage and TSTORE (0x5d) for storing data to transient storage.\n\nThe key benefit of transient storage is significant gas savings compared to traditional storage operations. This makes it ideal for temporary data that doesn't need to persist beyond a single transaction, such as reentrancy guards, intermediate calculation results, or temporary state tracking.\n\nWhile not explicitly used in the Immutable Ratings contracts shown, implementing EIP-1153 could provide gas optimizations for operations like rating calculations, market creation, or security mechanisms. As of Solidity 0.8.24, these opcodes are supported in the Cancun hardfork, though they currently require inline assembly to use directly in smart contracts."
  },
  {
    "terms": [
      "DEX"
    ],
    "definition": "# DEX\n\nA Decentralized Exchange (DEX) is a peer-to-peer marketplace for trading cryptocurrencies without intermediaries. Unlike centralized exchanges, DEXs operate through smart contracts on blockchain networks, allowing users to maintain custody of their assets while trading directly from their wallets.\n\nKey characteristics of DEXs include:\n\n1. **Non-custodial**: Users retain control of their private keys and tokens\n2. **Permissionless**: Anyone can access and use DEXs without KYC verification\n3. **On-chain settlement**: Transactions are executed and settled on the blockchain\n4. **Automated Market Makers (AMMs)**: Many DEXs use liquidity pools with algorithmic pricing instead of order books\n5. **Liquidity provision**: Users can become liquidity providers by depositing token pairs into pools and earn fees\n\nPopular DEX implementations include Uniswap, SushiSwap, and Curve on Ethereum, with similar platforms existing across other blockchain ecosystems."
  },
  {
    "terms": [
      "ERC721"
    ],
    "definition": "# ERC721\n\nERC721 is a standard for non-fungible tokens (NFTs) on the Ethereum blockchain that defines a set of required functions and events for implementing unique, distinct tokens. Unlike the ERC20 tokens used in the Immutable Ratings system (TUP and TDN tokens), which are fungible and identical to each other, ERC721 tokens have unique identifiers and cannot be exchanged on a 1:1 basis.\n\nThe ERC721 standard includes core functions such as:\n- `balanceOf(address owner)`: Returns how many NFTs an address owns\n- `ownerOf(uint256 tokenId)`: Returns the owner of a specific token\n- `transferFrom(address from, address to, uint256 tokenId)`: Transfers ownership\n- `approve(address to, uint256 tokenId)`: Grants permission to transfer a specific token\n- `getApproved(uint256 tokenId)`: Returns the approved address for a token\n\nERC721 tokens are commonly used for digital collectibles, art, game items, and representing ownership of unique assets or rights. While not implemented in the Immutable Ratings codebase (which uses ERC20 tokens for cumulative ratings), ERC721 would be appropriate if the system needed to track individual, unique ratings with distinct properties rather than simple cumulative scores."
  },
  {
    "terms": [
      "EIP-712"
    ],
    "definition": "# EIP-712\n\nEIP-712 (Ethereum Improvement Proposal 712) is a standard for typed structured data hashing and signing in Ethereum. Unlike traditional message signing where users see only a cryptographic hash, EIP-712 presents data in a human-readable format, making it clear what users are actually signing.\n\nThe standard enables applications to create structured typed data with a schema that can be displayed in wallets, showing users the actual content they're authorizing rather than opaque hex strings. This is accomplished through a domain separator (preventing cross-application replay attacks) and a structured data format with defined types.\n\nIn decentralized applications like ratings systems or exchanges, EIP-712 is crucial for securely signing off-chain orders or transactions while ensuring users understand exactly what they're approving. The technical implementation involves creating a hash of the form `0x19 0x01 <domainSeparator> <hashStruct(message)>`, which is then signed with the user's private key.\n\nThis approach significantly improves both security and user experience by preventing signature replay attacks and reducing the likelihood of users approving malicious transactions due to unclear signing prompts."
  },
  {
    "terms": [
      "Time-Weighted Average Market Maker (TWAMM)",
      "TWAMM"
    ],
    "definition": "# Time-Weighted Average Market Maker (TWAMM)\n\nTime-Weighted Average Market Maker (TWAMM) is a mechanism in decentralized exchanges that executes large orders gradually over an extended period rather than all at once. By splitting a large trade into many smaller trades executed at regular intervals, TWAMMs calculate a time-weighted average price, significantly reducing price impact and slippage that would otherwise occur with large single-block transactions. This approach allows traders to execute substantial positions without disrupting market conditions or telegraphing their trading intentions. TWAMMs are particularly valuable for large-scale traders, DAOs, and treasury management operations that need to minimize execution costs when dealing with substantial positions in liquidity-constrained markets.\n\nUnlike standard AMMs that execute trades immediately, TWAMMs perform continuous, algorithmic execution that simulates the traditional TCA (Time-Weighted Average Price) strategies from traditional finance, but in a fully on-chain, trustless manner. This mechanism has been implemented in various forms across protocols like Uniswap v4, Pendle, and other advanced DEX platforms that seek to provide more sophisticated trading primitives directly at the protocol level."
  },
  {
    "terms": [
      "Variant Maps"
    ],
    "definition": "# Variant Maps\n\nA binary encoding pattern used to efficiently pack multiple boolean flags or configuration options into a single byte or word. Variant maps optimize gas consumption in blockchain applications by reducing storage requirements and simplifying flag operations. Rather than storing each boolean property separately (which would consume at least one byte per flag), variant maps use bitwise operations to pack multiple flags into a single storage slot. This pattern is particularly valuable in gas-constrained environments like Ethereum where every byte of storage has a cost.\n\nIn implementations, variant maps are typically accessed through type-safe wrapper structures that provide clear methods to read and modify specific bits, maintaining code readability while achieving storage efficiency. Each bit position represents a different property or flag, allowing developers to query or modify properties through bitwise operations like AND, OR, and XOR."
  },
  {
    "terms": [
      "ECDSA"
    ],
    "definition": "# ECDSA\n\nECDSA (Elliptic Curve Digital Signature Algorithm) is a cryptographic algorithm used for digital signatures in blockchain systems. It provides a way to:\n\n1. **Sign messages** using a private key, proving the message came from you\n2. **Verify signatures** using a public key, confirming who sent a message\n3. **Recover addresses** from signatures, which is crucial for Ethereum's transaction validation\n\nECDSA uses elliptic curve mathematics to create signatures that are more compact than traditional algorithms like RSA while maintaining equivalent security strength. In Ethereum and Solidity, ECDSA powers critical operations like transaction signing, message verification, and access control systems.\n\nThe algorithm generates signatures with three components:\n- **r**: First output of the elliptic curve calculation\n- **s**: Second output (which must be in the lower range to prevent signature malleability)\n- **v**: Recovery identifier used to determine the signer's public key\n\nEthereum's implementation includes the `ecrecover` precompile, which efficiently recovers the signer's address from these components, allowing contracts to verify who authorized a particular action without storing public keys."
  },
  {
    "terms": [
      "ERC1271"
    ],
    "definition": "# ERC1271\n\nERC1271 is a standard interface that allows smart contracts to validate signatures. It defines a method called `isValidSignature` that takes a message hash and signature as inputs, returning a specific \"magic value\" (`0x1626ba7e`) when the signature is valid.\n\nThe core interface is simple:\n\n```solidity\ninterface IERC1271 {\n    function isValidSignature(bytes32 hash, bytes memory signature) \n        external view returns (bytes4 magicValue);\n}\n```\n\nThis standard is crucial for enabling smart contract wallets to participate in systems that traditionally only supported Externally Owned Accounts (EOAs). By implementing ERC1271, smart contracts can define custom signature validation logic, enabling features like:\n\n- Multi-signature verification\n- Time-bound signatures\n- Signature delegation\n- Gas-efficient signature verification\n\nIn the context of systems like Immutable Ratings, ERC1271 would allow users with smart contract wallets to submit ratings, enabling broader participation in the platform beyond traditional EOA wallet users. It forms a key building block for account abstraction and increases the interoperability of signature-based systems across the Ethereum ecosystem."
  },
  {
    "terms": [
      "Application-Specific Sequencing (ASS)",
      "Application-Specific Sequencing",
      "(ASS)"
    ],
    "definition": "# Application-Specific Sequencing (ASS)\n\nApplication-Specific Sequencing (ASS) is a blockchain architecture pattern that allows individual applications to define and control the ordering of their own transactions, rather than relying on the default sequencing mechanisms of the underlying blockchain protocol. \n\nIn traditional blockchain systems, transaction ordering is typically determined by network validators or miners using protocol-wide rules (like gas price in Ethereum). ASS enables applications to implement custom sequencing logic tailored to their specific needs, which can improve user experience, reduce front-running, minimize miner extractable value (MEV), and optimize for application-specific fairness criteria.\n\nUnlike application-specific blockchains (\"appchains\"), which require building entirely separate chains with dedicated validators, ASS allows applications to maintain presence on a shared blockchain while gaining autonomy over transaction ordering. This preserves valuable properties like asset composability and security while giving applications more control over their transaction flow.\n\nASS represents an important middle ground in the blockchain scalability trilemma, offering a balance between decentralization, security, and the customization needed for specialized applications."
  },
  {
    "terms": [
      "MEV (Maximal Extractable Value)",
      "MEV",
      "Maximal Extractable Value"
    ],
    "definition": "# MEV (Maximal Extractable Value)\n\nMEV refers to the maximum profit that can be extracted from blockchain networks by manipulating transaction ordering, inclusion, or censorship within blocks. Originally called \"Miner Extractable Value\" in Proof-of-Work systems, it was renamed \"Maximal Extractable Value\" to reflect that validators and other actors can also extract this value in various consensus mechanisms.\n\nMEV extraction occurs through techniques like:\n- Front-running user transactions\n- Sandwiching trades between buy and sell orders\n- Arbitraging price differences across platforms\n- Strategic transaction reordering\n\nThis extraction represents an \"invisible tax\" on blockchain users, as it diverts value that would otherwise remain with traders and liquidity providers. Many DeFi protocols implement MEV mitigation strategies to create fairer systems, such as:\n\n- Batch processing orders at uniform prices\n- Implementing auctions that redistribute extracted value\n- Using mechanisms that prevent transaction reordering\n\nWell-designed MEV mitigation is critical for creating equitable and efficient DeFi ecosystems that protect users from predatory transaction manipulation."
  },
  {
    "terms": [
      "Orderbook"
    ],
    "definition": "# Orderbook\n\nAn orderbook is a fundamental data structure in trading systems that maintains and organizes buy (bid) and sell (ask) orders for a specific asset or trading pair. \n\nIt consists of:\n- A unique identifier for the trading pair (PoolId)\n- Two sorted collections: one for buy orders (bids) and one for sell orders (asks)\n- Sometimes an optional AMM (Automated Market Maker) snapshot for hybrid markets\n\nOrders in each collection are typically sorted by price (descending for bids, ascending for asks) and then by time priority or volume. This organization enables efficient order matching, price discovery, and provides market participants with visibility into current market depth and liquidity.\n\nThe orderbook represents the current state of supply and demand for an asset, serving as the core component that a matching engine uses to pair buyers and sellers in a trading system."
  },
  {
    "terms": [
      "Top-of-Block (ToB)",
      "Top-of-Block",
      "ToB"
    ],
    "definition": "# Top-of-Block (ToB)\n\nTop-of-Block (ToB) is a specialized transaction ordering mechanism in blockchain systems that ensures specific transactions are executed at the beginning of a newly created block. \n\nToB orders are structured with precise specifications including asset quantities, gas limits, validity constraints tied to specific block numbers, and recipient information. By positioning these transactions at the \"top\" of the block's execution queue, they receive priority processing before other transactions.\n\nThis mechanism is particularly valuable in decentralized finance (DeFi) applications where transaction timing and order can significantly impact outcomes. Traders use ToB orders to:\n\n- Execute time-sensitive trades with minimal slippage\n- Capitalize on fleeting market inefficiencies\n- Gain positional advantages in competitive trading scenarios\n- Front-run potential price movements caused by subsequent transactions\n\nThe implementation typically involves specialized smart contracts that interface with block producers to ensure proper positioning of these prioritized transactions within the blockchain's execution sequence."
  }
]